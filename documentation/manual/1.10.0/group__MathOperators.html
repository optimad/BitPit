---
layout: doxygen_header
title: Manual - Mathematical Operators
section: documentation
doxygen-show-titlearea: 0
extra-head-includes:
    - doxygen_extra_head.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
{% if page.doxygen-show-titlearea == 1 %}
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">bitpit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
{% endif %}
<!-- end header part -->
{% raw %}
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Mathematical Operators<div class="ingroups"><a class="el" href="group__OperatorsFunctions.html">Operators and Functions</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Mathematical Operators:</div>
<div class="dyncontent">
<div class="center"><img src="group__MathOperators.png" border="0" usemap="#agroup____MathOperators" alt=""/></div>
<map name="agroup____MathOperators" id="agroup____MathOperators">
<area shape="rect" title=" " alt="" coords="219,5,380,31"/>
<area shape="rect" href="group__OperatorsFunctions.html" title=" " alt="" coords="5,5,171,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="memitem:gad5dea4f58756ac4d324d7a96fb16d095" id="r_gad5dea4f58756ac4d324d7a96fb16d095"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gad5dea4f58756ac4d324d7a96fb16d095"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad5dea4f58756ac4d324d7a96fb16d095">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gad5dea4f58756ac4d324d7a96fb16d095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8b9ef31e10db314beda4425430ec00" id="r_ga8d8b9ef31e10db314beda4425430ec00"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga8d8b9ef31e10db314beda4425430ec00"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8d8b9ef31e10db314beda4425430ec00">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8d8b9ef31e10db314beda4425430ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e7b30a7bf5b0fc641f7f26ddbe2348" id="r_gac6e7b30a7bf5b0fc641f7f26ddbe2348"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gac6e7b30a7bf5b0fc641f7f26ddbe2348"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac6e7b30a7bf5b0fc641f7f26ddbe2348">operator+</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gac6e7b30a7bf5b0fc641f7f26ddbe2348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6184fa5a54822e79d24116653a7cc02a" id="r_ga6184fa5a54822e79d24116653a7cc02a"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga6184fa5a54822e79d24116653a7cc02a"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6184fa5a54822e79d24116653a7cc02a">operator+</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga6184fa5a54822e79d24116653a7cc02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6eb7203ac9d396281ce7948ca77b99b" id="r_gac6eb7203ac9d396281ce7948ca77b99b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gac6eb7203ac9d396281ce7948ca77b99b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac6eb7203ac9d396281ce7948ca77b99b">operator+</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac6eb7203ac9d396281ce7948ca77b99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbf957c8e29539b76d5a29aab13ebca" id="r_ga3fbf957c8e29539b76d5a29aab13ebca"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3fbf957c8e29539b76d5a29aab13ebca"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3fbf957c8e29539b76d5a29aab13ebca">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3fbf957c8e29539b76d5a29aab13ebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a70766353e95c78ae9b5c7b56b5ba7" id="r_ga89a70766353e95c78ae9b5c7b56b5ba7"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga89a70766353e95c78ae9b5c7b56b5ba7"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga89a70766353e95c78ae9b5c7b56b5ba7">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga89a70766353e95c78ae9b5c7b56b5ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4dea55e35977b6cc046df52e78db126" id="r_gaf4dea55e35977b6cc046df52e78db126"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaf4dea55e35977b6cc046df52e78db126"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf4dea55e35977b6cc046df52e78db126">operator+=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaf4dea55e35977b6cc046df52e78db126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41fc7099c1967c331395b8f2bbfba52" id="r_gad41fc7099c1967c331395b8f2bbfba52"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gad41fc7099c1967c331395b8f2bbfba52"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad41fc7099c1967c331395b8f2bbfba52">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gad41fc7099c1967c331395b8f2bbfba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c05b1ac15cbd3631059190bfa71363" id="r_gaf3c05b1ac15cbd3631059190bfa71363"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaf3c05b1ac15cbd3631059190bfa71363"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf3c05b1ac15cbd3631059190bfa71363">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaf3c05b1ac15cbd3631059190bfa71363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e31b587498592d868281e23e41968ec" id="r_ga0e31b587498592d868281e23e41968ec"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga0e31b587498592d868281e23e41968ec"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0e31b587498592d868281e23e41968ec">operator-</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga0e31b587498592d868281e23e41968ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5133809dcbdc513c238bedb9943b0375" id="r_ga5133809dcbdc513c238bedb9943b0375"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga5133809dcbdc513c238bedb9943b0375"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5133809dcbdc513c238bedb9943b0375">operator-</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga5133809dcbdc513c238bedb9943b0375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc769ecc8b03395adc1d5ac5aab1e89c" id="r_gacc769ecc8b03395adc1d5ac5aab1e89c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gacc769ecc8b03395adc1d5ac5aab1e89c"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacc769ecc8b03395adc1d5ac5aab1e89c">operator-</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gacc769ecc8b03395adc1d5ac5aab1e89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08fe06026beca2ceb67f0dceed31b531" id="r_ga08fe06026beca2ceb67f0dceed31b531"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga08fe06026beca2ceb67f0dceed31b531"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga08fe06026beca2ceb67f0dceed31b531">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga08fe06026beca2ceb67f0dceed31b531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fefa8b35f1f38d70c2dfff298346e5" id="r_ga67fefa8b35f1f38d70c2dfff298346e5"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga67fefa8b35f1f38d70c2dfff298346e5"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga67fefa8b35f1f38d70c2dfff298346e5">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga67fefa8b35f1f38d70c2dfff298346e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3c8bf3bd9204c55d991affed1bdfb0" id="r_ga8b3c8bf3bd9204c55d991affed1bdfb0"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga8b3c8bf3bd9204c55d991affed1bdfb0"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8b3c8bf3bd9204c55d991affed1bdfb0">operator-=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8b3c8bf3bd9204c55d991affed1bdfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877548575dd334f23f36fb0f58049a35" id="r_ga877548575dd334f23f36fb0f58049a35"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga877548575dd334f23f36fb0f58049a35"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga877548575dd334f23f36fb0f58049a35">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga877548575dd334f23f36fb0f58049a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4415b55222fb22edfccc7211c3d28e" id="r_gacd4415b55222fb22edfccc7211c3d28e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gacd4415b55222fb22edfccc7211c3d28e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacd4415b55222fb22edfccc7211c3d28e">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gacd4415b55222fb22edfccc7211c3d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002eceb71d95d7a8ea55c4086f4bc19f" id="r_ga002eceb71d95d7a8ea55c4086f4bc19f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga002eceb71d95d7a8ea55c4086f4bc19f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga002eceb71d95d7a8ea55c4086f4bc19f">operator*</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga002eceb71d95d7a8ea55c4086f4bc19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8b5e13a060be1c2d00ea525f55cd15" id="r_ga8d8b5e13a060be1c2d00ea525f55cd15"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga8d8b5e13a060be1c2d00ea525f55cd15"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8d8b5e13a060be1c2d00ea525f55cd15">operator*</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga8d8b5e13a060be1c2d00ea525f55cd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab938def11e8fa33e200234a7f87fd60b" id="r_gab938def11e8fa33e200234a7f87fd60b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gab938def11e8fa33e200234a7f87fd60b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab938def11e8fa33e200234a7f87fd60b">operator*</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gab938def11e8fa33e200234a7f87fd60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01dd64145ceceed6f11d076b595dd5b1" id="r_ga01dd64145ceceed6f11d076b595dd5b1"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga01dd64145ceceed6f11d076b595dd5b1"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga01dd64145ceceed6f11d076b595dd5b1">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga01dd64145ceceed6f11d076b595dd5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc5c8373acd57721d425876bffeebd9" id="r_ga3cc5c8373acd57721d425876bffeebd9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3cc5c8373acd57721d425876bffeebd9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3cc5c8373acd57721d425876bffeebd9">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga3cc5c8373acd57721d425876bffeebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276768d794bae4dfcf7b07d269b4a6b3" id="r_ga276768d794bae4dfcf7b07d269b4a6b3"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga276768d794bae4dfcf7b07d269b4a6b3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga276768d794bae4dfcf7b07d269b4a6b3">operator*=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga276768d794bae4dfcf7b07d269b4a6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1224ce75f96a1531fa86fa4365f725" id="r_ga1f1224ce75f96a1531fa86fa4365f725"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1f1224ce75f96a1531fa86fa4365f725"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1f1224ce75f96a1531fa86fa4365f725">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1f1224ce75f96a1531fa86fa4365f725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571bed97e1f9dc43162ed05c86c7297f" id="r_ga571bed97e1f9dc43162ed05c86c7297f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga571bed97e1f9dc43162ed05c86c7297f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga571bed97e1f9dc43162ed05c86c7297f">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga571bed97e1f9dc43162ed05c86c7297f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37768937a2c3d0c96284bd20f2799fc7" id="r_ga37768937a2c3d0c96284bd20f2799fc7"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga37768937a2c3d0c96284bd20f2799fc7"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga37768937a2c3d0c96284bd20f2799fc7">operator/</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga37768937a2c3d0c96284bd20f2799fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b" id="r_gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b">operator/</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46faa02af5bf7ce75bbb1ba8b16cf16" id="r_gac46faa02af5bf7ce75bbb1ba8b16cf16"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gac46faa02af5bf7ce75bbb1ba8b16cf16"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac46faa02af5bf7ce75bbb1ba8b16cf16">operator/</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac46faa02af5bf7ce75bbb1ba8b16cf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8622b683eb6d38f3ca2eee11f9045d" id="r_ga7b8622b683eb6d38f3ca2eee11f9045d"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga7b8622b683eb6d38f3ca2eee11f9045d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7b8622b683eb6d38f3ca2eee11f9045d">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga7b8622b683eb6d38f3ca2eee11f9045d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab7a46cda45f5c95e31e14b0cb2d44a" id="r_gadab7a46cda45f5c95e31e14b0cb2d44a"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gadab7a46cda45f5c95e31e14b0cb2d44a"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadab7a46cda45f5c95e31e14b0cb2d44a">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gadab7a46cda45f5c95e31e14b0cb2d44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edd77a9cc40f7e0640eeef310d60c32" id="r_ga1edd77a9cc40f7e0640eeef310d60c32"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga1edd77a9cc40f7e0640eeef310d60c32"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1edd77a9cc40f7e0640eeef310d60c32">operator/=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga1edd77a9cc40f7e0640eeef310d60c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f" id="r_ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga71b722bb9670854ddfcb0e867620083f">operator+</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga71b722bb9670854ddfcb0e867620083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee" id="r_ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga97948a906b46303c7c654c84149dd9ee">operator+</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga97948a906b46303c7c654c84149dd9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f" id="r_gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gade9e3b35c5ed9d228bd242eaee48df2f">operator+</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f" id="r_ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga06cb1fde86b09befdc0b42d99fdbf31f">operator+</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c" id="r_ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6e163effd6e58c7f726fbd29f5c1e42c">operator+</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e384cc363f7a533e84233d0781d063" id="r_gab1e384cc363f7a533e84233d0781d063"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab1e384cc363f7a533e84233d0781d063"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab1e384cc363f7a533e84233d0781d063">operator+=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gab1e384cc363f7a533e84233d0781d063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2547f5a2792bfa7f168003900c31a320" id="r_ga2547f5a2792bfa7f168003900c31a320"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2547f5a2792bfa7f168003900c31a320"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2547f5a2792bfa7f168003900c31a320">operator+=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga2547f5a2792bfa7f168003900c31a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706563d638b3361e51e8a376d86e4206" id="r_ga706563d638b3361e51e8a376d86e4206"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga706563d638b3361e51e8a376d86e4206"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga706563d638b3361e51e8a376d86e4206">operator+=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga706563d638b3361e51e8a376d86e4206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1" id="r_ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga39b3f7b4938cab605085cc4a2621c0c1">operator-</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9" id="r_ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8b14f28bd4c6544e7af363162827a3f9">operator-</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93" id="r_ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga81916c6a47f24b1ec5bfb890a7e71d93">operator-</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa" id="r_gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacd869d6ee14d5683b3fa4fcefc5ae5fa">operator-</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0" id="r_ga043799b065672b453653cccc836df3e0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga043799b065672b453653cccc836df3e0">operator-</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043799b065672b453653cccc836df3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8ca10f1be3a4ef73728199de095951" id="r_ga6c8ca10f1be3a4ef73728199de095951"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6c8ca10f1be3a4ef73728199de095951"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6c8ca10f1be3a4ef73728199de095951">operator-=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga6c8ca10f1be3a4ef73728199de095951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae2c7c7dd3909e0c79b00ad4f179d07" id="r_ga0ae2c7c7dd3909e0c79b00ad4f179d07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0ae2c7c7dd3909e0c79b00ad4f179d07"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0ae2c7c7dd3909e0c79b00ad4f179d07">operator-=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga0ae2c7c7dd3909e0c79b00ad4f179d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59762030d80b896a612f791781fcd777" id="r_ga59762030d80b896a612f791781fcd777"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga59762030d80b896a612f791781fcd777"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga59762030d80b896a612f791781fcd777">operator-=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga59762030d80b896a612f791781fcd777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba" id="r_ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2bd9e5a66f35bd5cfe4903f2405c87ba">operator*</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e" id="r_gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac44d2a365e67d48fc144cf576f4e003e">operator*</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac44d2a365e67d48fc144cf576f4e003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b" id="r_ga92fa8968855d071e34808339503fe37b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga92fa8968855d071e34808339503fe37b">operator*</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga92fa8968855d071e34808339503fe37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3" id="r_gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae5c14d292d187b6a76d4acd8068e2ec3">operator*</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2" id="r_ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5be9b506ad98c26a66c46e3a63569af2">operator*</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc463927e1f8a7a6104ca8338bd81804" id="r_gadc463927e1f8a7a6104ca8338bd81804"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadc463927e1f8a7a6104ca8338bd81804"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadc463927e1f8a7a6104ca8338bd81804">operator*=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gadc463927e1f8a7a6104ca8338bd81804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4a87f31a74b77936427c1f3ea9a87b" id="r_gadd4a87f31a74b77936427c1f3ea9a87b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadd4a87f31a74b77936427c1f3ea9a87b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadd4a87f31a74b77936427c1f3ea9a87b">operator*=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gadd4a87f31a74b77936427c1f3ea9a87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa472781ea862caff490ba96e6cb222a4" id="r_gaa472781ea862caff490ba96e6cb222a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa472781ea862caff490ba96e6cb222a4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa472781ea862caff490ba96e6cb222a4">operator*=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaa472781ea862caff490ba96e6cb222a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0" id="r_ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4d9d274530965b0fb1a331706535b2b0">operator/</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4d9d274530965b0fb1a331706535b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20" id="r_ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9ee9c85d60d975df735a1c35fcf02e20">operator/</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f" id="r_gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac6fff4de3b1f6cbedc8b80e0f29b673f">operator/</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4" id="r_gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaaa8866a1e9873585704acfa8169ba1f4">operator/</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d" id="r_gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab73845b94584f17c7e810e27cba36f5d">operator/</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gab73845b94584f17c7e810e27cba36f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c760e4fb64cdc1b52bf2c589d77436e" id="r_ga9c760e4fb64cdc1b52bf2c589d77436e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9c760e4fb64cdc1b52bf2c589d77436e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9c760e4fb64cdc1b52bf2c589d77436e">operator/=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga9c760e4fb64cdc1b52bf2c589d77436e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac299c00791946cdbae7cdb8a54b3fc" id="r_ga9ac299c00791946cdbae7cdb8a54b3fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ac299c00791946cdbae7cdb8a54b3fc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9ac299c00791946cdbae7cdb8a54b3fc">operator/=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga9ac299c00791946cdbae7cdb8a54b3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7471ac1e321cb428d90510d46edbc7" id="r_ga7d7471ac1e321cb428d90510d46edbc7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7d7471ac1e321cb428d90510d46edbc7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7d7471ac1e321cb428d90510d46edbc7">operator/=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7d7471ac1e321cb428d90510d46edbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab938def11e8fa33e200234a7f87fd60b" name="gab938def11e8fa33e200234a7f87fd60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab938def11e8fa33e200234a7f87fd60b">&#9670;&#160;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::array, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00871">871</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga877548575dd334f23f36fb0f58049a35" name="ga877548575dd334f23f36fb0f58049a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga877548575dd334f23f36fb0f58049a35">&#9670;&#160;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between two arrays (x and y) and returns a array z s.t. z[i] = x[i] * y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00715">715</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gacd4415b55222fb22edfccc7211c3d28e" name="gacd4415b55222fb22edfccc7211c3d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd4415b55222fb22edfccc7211c3d28e">&#9670;&#160;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] * y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00754">754</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga5be9b506ad98c26a66c46e3a63569af2" name="ga5be9b506ad98c26a66c46e3a63569af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be9b506ad98c26a66c46e3a63569af2">&#9670;&#160;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00862">862</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga2bd9e5a66f35bd5cfe4903f2405c87ba" name="ga2bd9e5a66f35bd5cfe4903f2405c87ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd9e5a66f35bd5cfe4903f2405c87ba">&#9670;&#160;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] * y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00703">703</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac44d2a365e67d48fc144cf576f4e003e" name="gac44d2a365e67d48fc144cf576f4e003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44d2a365e67d48fc144cf576f4e003e">&#9670;&#160;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] * y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00743">743</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8d8b5e13a060be1c2d00ea525f55cd15" name="ga8d8b5e13a060be1c2d00ea525f55cd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8b5e13a060be1c2d00ea525f55cd15">&#9670;&#160;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::array, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00831">831</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga002eceb71d95d7a8ea55c4086f4bc19f" name="ga002eceb71d95d7a8ea55c4086f4bc19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002eceb71d95d7a8ea55c4086f4bc19f">&#9670;&#160;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x * y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00793">793</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gae5c14d292d187b6a76d4acd8068e2ec3" name="gae5c14d292d187b6a76d4acd8068e2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c14d292d187b6a76d4acd8068e2ec3">&#9670;&#160;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00821">821</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga92fa8968855d071e34808339503fe37b" name="ga92fa8968855d071e34808339503fe37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92fa8968855d071e34808339503fe37b">&#9670;&#160;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x * y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00783">783</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga276768d794bae4dfcf7b07d269b4a6b3" name="ga276768d794bae4dfcf7b07d269b4a6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276768d794bae4dfcf7b07d269b4a6b3">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00987">987</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga01dd64145ceceed6f11d076b595dd5b1" name="ga01dd64145ceceed6f11d076b595dd5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01dd64145ceceed6f11d076b595dd5b1">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00911">911</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga3cc5c8373acd57721d425876bffeebd9" name="ga3cc5c8373acd57721d425876bffeebd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cc5c8373acd57721d425876bffeebd9">&#9670;&#160;</a></span>operator*=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00949">949</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaa472781ea862caff490ba96e6cb222a4" name="gaa472781ea862caff490ba96e6cb222a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa472781ea862caff490ba96e6cb222a4">&#9670;&#160;</a></span>operator*=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00979">979</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gadc463927e1f8a7a6104ca8338bd81804" name="gadc463927e1f8a7a6104ca8338bd81804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc463927e1f8a7a6104ca8338bd81804">&#9670;&#160;</a></span>operator*=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00901">901</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gadd4a87f31a74b77936427c1f3ea9a87b" name="gadd4a87f31a74b77936427c1f3ea9a87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd4a87f31a74b77936427c1f3ea9a87b">&#9670;&#160;</a></span>operator*=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00940">940</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac6eb7203ac9d396281ce7948ca77b99b" name="gac6eb7203ac9d396281ce7948ca77b99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6eb7203ac9d396281ce7948ca77b99b">&#9670;&#160;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00230">230</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gad5dea4f58756ac4d324d7a96fb16d095" name="gad5dea4f58756ac4d324d7a96fb16d095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5dea4f58756ac4d324d7a96fb16d095">&#9670;&#160;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array</p>
<p>Perform the element-wise sum between two arrays (x and y) and returns a array z s.t. z[i] = x[i] + y[i] for all i = 0, ..., d where d = x.size() = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00074">74</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga8d8b9ef31e10db314beda4425430ec00" name="ga8d8b9ef31e10db314beda4425430ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8b9ef31e10db314beda4425430ec00">&#9670;&#160;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] + y for all i = 0, ..., d where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00113">113</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga06cb1fde86b09befdc0b42d99fdbf31f" name="ga06cb1fde86b09befdc0b42d99fdbf31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cb1fde86b09befdc0b42d99fdbf31f">&#9670;&#160;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00187">187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga71b722bb9670854ddfcb0e867620083f" name="ga71b722bb9670854ddfcb0e867620083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b722bb9670854ddfcb0e867620083f">&#9670;&#160;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] + y[i] for all i = 0, ..., n-1 where n = std::min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00069">69</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga97948a906b46303c7c654c84149dd9ee" name="ga97948a906b46303c7c654c84149dd9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97948a906b46303c7c654c84149dd9ee">&#9670;&#160;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] + y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00109">109</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga6184fa5a54822e79d24116653a7cc02a" name="ga6184fa5a54822e79d24116653a7cc02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6184fa5a54822e79d24116653a7cc02a">&#9670;&#160;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00190">190</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gac6e7b30a7bf5b0fc641f7f26ddbe2348" name="gac6e7b30a7bf5b0fc641f7f26ddbe2348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e7b30a7bf5b0fc641f7f26ddbe2348">&#9670;&#160;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x + y[i] for all i = 0, ..., d where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00152">152</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga6e163effd6e58c7f726fbd29f5c1e42c" name="ga6e163effd6e58c7f726fbd29f5c1e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e163effd6e58c7f726fbd29f5c1e42c">&#9670;&#160;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00228">228</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gade9e3b35c5ed9d228bd242eaee48df2f" name="gade9e3b35c5ed9d228bd242eaee48df2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9e3b35c5ed9d228bd242eaee48df2f">&#9670;&#160;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x + y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00149">149</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaf4dea55e35977b6cc046df52e78db126" name="gaf4dea55e35977b6cc046df52e78db126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4dea55e35977b6cc046df52e78db126">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00344">344</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga3fbf957c8e29539b76d5a29aab13ebca" name="ga3fbf957c8e29539b76d5a29aab13ebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fbf957c8e29539b76d5a29aab13ebca">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00268">268</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga89a70766353e95c78ae9b5c7b56b5ba7" name="ga89a70766353e95c78ae9b5c7b56b5ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a70766353e95c78ae9b5c7b56b5ba7">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga706563d638b3361e51e8a376d86e4206" name="ga706563d638b3361e51e8a376d86e4206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga706563d638b3361e51e8a376d86e4206">&#9670;&#160;</a></span>operator+=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00345">345</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gab1e384cc363f7a533e84233d0781d063" name="gab1e384cc363f7a533e84233d0781d063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e384cc363f7a533e84233d0781d063">&#9670;&#160;</a></span>operator+=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00267">267</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga2547f5a2792bfa7f168003900c31a320" name="ga2547f5a2792bfa7f168003900c31a320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2547f5a2792bfa7f168003900c31a320">&#9670;&#160;</a></span>operator+=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gacc769ecc8b03395adc1d5ac5aab1e89c" name="gacc769ecc8b03395adc1d5ac5aab1e89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc769ecc8b03395adc1d5ac5aab1e89c">&#9670;&#160;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., e-1, i = 0, ..., d-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::array, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00541">541</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gad41fc7099c1967c331395b8f2bbfba52" name="gad41fc7099c1967c331395b8f2bbfba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad41fc7099c1967c331395b8f2bbfba52">&#9670;&#160;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between two arrays (x and y) and returns a array z s.t. z[i] = x[i] - y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00385">385</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaf3c05b1ac15cbd3631059190bfa71363" name="gaf3c05b1ac15cbd3631059190bfa71363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c05b1ac15cbd3631059190bfa71363">&#9670;&#160;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] - y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00424">424</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga043799b065672b453653cccc836df3e0" name="ga043799b065672b453653cccc836df3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043799b065672b453653cccc836df3e0">&#9670;&#160;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::vector, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00545">545</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga39b3f7b4938cab605085cc4a2621c0c1" name="ga39b3f7b4938cab605085cc4a2621c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39b3f7b4938cab605085cc4a2621c0c1">&#9670;&#160;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] - y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00386">386</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8b14f28bd4c6544e7af363162827a3f9" name="ga8b14f28bd4c6544e7af363162827a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b14f28bd4c6544e7af363162827a3f9">&#9670;&#160;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] - y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00426">426</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga5133809dcbdc513c238bedb9943b0375" name="ga5133809dcbdc513c238bedb9943b0375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5133809dcbdc513c238bedb9943b0375">&#9670;&#160;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::array, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00501">501</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga0e31b587498592d868281e23e41968ec" name="ga0e31b587498592d868281e23e41968ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e31b587498592d868281e23e41968ec">&#9670;&#160;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x - y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00463">463</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gacd869d6ee14d5683b3fa4fcefc5ae5fa" name="gacd869d6ee14d5683b3fa4fcefc5ae5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd869d6ee14d5683b3fa4fcefc5ae5fa">&#9670;&#160;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::vector, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00504">504</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga81916c6a47f24b1ec5bfb890a7e71d93" name="ga81916c6a47f24b1ec5bfb890a7e71d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81916c6a47f24b1ec5bfb890a7e71d93">&#9670;&#160;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x - y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00466">466</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8b3c8bf3bd9204c55d991affed1bdfb0" name="ga8b3c8bf3bd9204c55d991affed1bdfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3c8bf3bd9204c55d991affed1bdfb0">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::array, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00674">674</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga08fe06026beca2ceb67f0dceed31b531" name="ga08fe06026beca2ceb67f0dceed31b531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08fe06026beca2ceb67f0dceed31b531">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the corresping value on the array at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00579">579</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga67fefa8b35f1f38d70c2dfff298346e5" name="ga67fefa8b35f1f38d70c2dfff298346e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67fefa8b35f1f38d70c2dfff298346e5">&#9670;&#160;</a></span>operator-=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::array, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00617">617</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga59762030d80b896a612f791781fcd777" name="ga59762030d80b896a612f791781fcd777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59762030d80b896a612f791781fcd777">&#9670;&#160;</a></span>operator-=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::vector, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00662">662</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga6c8ca10f1be3a4ef73728199de095951" name="ga6c8ca10f1be3a4ef73728199de095951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c8ca10f1be3a4ef73728199de095951">&#9670;&#160;</a></span>operator-=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the corresping value on vector at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00584">584</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga0ae2c7c7dd3909e0c79b00ad4f179d07" name="ga0ae2c7c7dd3909e0c79b00ad4f179d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae2c7c7dd3909e0c79b00ad4f179d07">&#9670;&#160;</a></span>operator-=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::vector, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00623">623</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac46faa02af5bf7ce75bbb1ba8b16cf16" name="gac46faa02af5bf7ce75bbb1ba8b16cf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac46faa02af5bf7ce75bbb1ba8b16cf16">&#9670;&#160;</a></span>operator/() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01191">1191</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga1f1224ce75f96a1531fa86fa4365f725" name="ga1f1224ce75f96a1531fa86fa4365f725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1224ce75f96a1531fa86fa4365f725">&#9670;&#160;</a></span>operator/() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between two arrays (x and y) and returns a array z s.t. z[i] = x[i] / y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01028">1028</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga571bed97e1f9dc43162ed05c86c7297f" name="ga571bed97e1f9dc43162ed05c86c7297f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga571bed97e1f9dc43162ed05c86c7297f">&#9670;&#160;</a></span>operator/() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] / y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01067">1067</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gab73845b94584f17c7e810e27cba36f5d" name="gab73845b94584f17c7e810e27cba36f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73845b94584f17c7e810e27cba36f5d">&#9670;&#160;</a></span>operator/() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01187">1187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga4d9d274530965b0fb1a331706535b2b0" name="ga4d9d274530965b0fb1a331706535b2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d9d274530965b0fb1a331706535b2b0">&#9670;&#160;</a></span>operator/() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] / y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01020">1020</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga9ee9c85d60d975df735a1c35fcf02e20" name="ga9ee9c85d60d975df735a1c35fcf02e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee9c85d60d975df735a1c35fcf02e20">&#9670;&#160;</a></span>operator/() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] / y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01060">1060</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b" name="gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b">&#9670;&#160;</a></span>operator/() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01151">1151</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga37768937a2c3d0c96284bd20f2799fc7" name="ga37768937a2c3d0c96284bd20f2799fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37768937a2c3d0c96284bd20f2799fc7">&#9670;&#160;</a></span>operator/() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x / y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01111">1111</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaaa8866a1e9873585704acfa8169ba1f4" name="gaaa8866a1e9873585704acfa8169ba1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8866a1e9873585704acfa8169ba1f4">&#9670;&#160;</a></span>operator/() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01146">1146</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac6fff4de3b1f6cbedc8b80e0f29b673f" name="gac6fff4de3b1f6cbedc8b80e0f29b673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6fff4de3b1f6cbedc8b80e0f29b673f">&#9670;&#160;</a></span>operator/() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x / y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01105">1105</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga1edd77a9cc40f7e0640eeef310d60c32" name="ga1edd77a9cc40f7e0640eeef310d60c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1edd77a9cc40f7e0640eeef310d60c32">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01291">1291</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga7b8622b683eb6d38f3ca2eee11f9045d" name="ga7b8622b683eb6d38f3ca2eee11f9045d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8622b683eb6d38f3ca2eee11f9045d">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01231">1231</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gadab7a46cda45f5c95e31e14b0cb2d44a" name="gadab7a46cda45f5c95e31e14b0cb2d44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab7a46cda45f5c95e31e14b0cb2d44a">&#9670;&#160;</a></span>operator/=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01261">1261</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga7d7471ac1e321cb428d90510d46edbc7" name="ga7d7471ac1e321cb428d90510d46edbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7471ac1e321cb428d90510d46edbc7">&#9670;&#160;</a></span>operator/=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01307">1307</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga9c760e4fb64cdc1b52bf2c589d77436e" name="ga9c760e4fb64cdc1b52bf2c589d77436e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c760e4fb64cdc1b52bf2c589d77436e">&#9670;&#160;</a></span>operator/=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01229">1229</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga9ac299c00791946cdbae7cdb8a54b3fc" name="ga9ac299c00791946cdbae7cdb8a54b3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ac299c00791946cdbae7cdb8a54b3fc">&#9670;&#160;</a></span>operator/=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01268">1268</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
</div><!-- contents -->
---
layout: doxygen_footer
---
{% endraw %}
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Fri Apr 26 2024 10:45:53 for bitpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.10.0
</small></address>
